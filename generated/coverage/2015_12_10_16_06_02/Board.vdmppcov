class Board
types
	public Player = <Black> | <Red>;
values
	public FILES = 9; -- width
	public RANKS = 10; --length
instance variables
	private currentPlayer: Player := <Red>;
	public board: map seq of nat1 to [Piece] := {|->};
	inv forall x in set dom board & x(1) in set {1,...,FILES} and x(2) in set {1,...,RANKS};
	
operations
 public init : () ==> ()
  init() ==
  (
  	board := {
  		[3,1] |-> new Elephant([3,1],<Red>),
  		[4,1] |-> new Advisor([4,1],<Red>),
  		[5,1] |-> new General([5,1],<Red>),
  	  [6,1] |-> new Advisor([6,1],<Red>),
  	  [7,1] |-> new Elephant([7,1],<Red>)
  	};
  );
	
	public moveTo: seq of nat1 * seq of nat1 ==> ()
	moveTo(coord1,coord2) ==(
		if( board(coord1).canMoveTo(coord2) and board(coord1).freeToMove(coord2,self)) then(
			if(isEmpty(coord2)   ) then(
				dcl pc1: Piece := board(coord1); 
				pc1.moveTo(coord2);
				board := board ++ { coord1 |-> nil};
				board := board ++ { coord2 |-> pc1 };
			)
			else if(isEatable(coord2) ) then(
				dcl pc1: Piece := board(coord1); 
				pc1.moveTo(coord2);
				board := board ++ { coord1 |-> nil};
				board := board ++ { coord2 |-> pc1 };
				board(coord1).moveTo(coord2);
			);
		);
	)
	pre coord1 <> coord2 and coord1 in set dom board and board(coord1) <> nil and board(coord1).color = currentPlayer; --verificar cordandas dentro ods limites
	
	public getPiece : seq of nat1 ==> Piece
	getPiece(coord) ==
		return board(coord)
	pre coord in set dom board and board(coord) <> nil;
	
	private isEatable : seq of nat1 ==> bool
	isEatable(coord) == 
		return currentPlayer <> board(coord).color
	pre coord in set dom board and board(coord) <> nil;
	
	public isEmpty : seq of nat1 ==> bool
	isEmpty(coord) == (
		if(coord in set dom board) then (
			return board(coord) = nil;
		)
		else(
			return true;
		)
	);	 
	public setPlayer: Player ==> ()
	setPlayer(plr) ==
		currentPlayer := plr;
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Board